import * as mozilla from 'source-map';

/**
 * @param plugins Can also be included with the Processor#use method.
 * @returns A processor that will apply plugins as CSS processors.
 */
declare function postcss(plugins?: postcss.AcceptedPlugin[]): postcss.Processor;
declare function postcss(...plugins: postcss.AcceptedPlugin[]): postcss.Processor;
declare namespace postcss {
  type AcceptedPlugin = Plugin<any> | Transformer | {
    postcss: TransformCallback | Processor;
  } | Processor;
  /**
   * Creates a PostCSS plugin with a standard API.
   * @param name Plugin name. Same as in name property in package.json. It will
   * be saved in plugin.postcssPlugin property.
   * @param initializer Will receive plugin options and should return functions
   * to modify nodes in input CSS.
   */
  function plugin<T>(name: string, initializer: PluginInitializer<T>): Plugin<T>;
  interface Plugin<T> extends Transformer {
    (opts?: T): Transformer;
    postcss: Transformer;
    process: (css: string | {
      toString(): string;
    } | Result, processOpts?: ProcessOptions, pluginOpts?: T) => LazyResult;
  }
  interface Transformer extends TransformCallback {
    postcssPlugin?: string;
    postcssVersion?: string;
  }
  interface TransformCallback {
    /**
     * @returns A Promise that resolves when all work is complete. May return
     * synchronously, but that style of plugin is only meant for debugging and
     * development. In either case, the resolved or returned value is not used -
     * the "result" is the output.
     */
    (root: Root, result: Result): Promise<any> | any;
  }
  interface PluginInitializer<T> {
    (pluginOptions?: T): Transformer;
  }
  /**
   * Contains helpers for working with vendor prefixes.
   */
  export namespace vendor {
    /**
     * @returns The vendor prefix extracted from the input string.
     */
    function prefix(prop: string): string;
    /**
     * @returns The input string stripped of its vendor prefix.
     */
    function unprefixed(prop: string): string;
  }
  type ParserInput = string | { toString(): string };
  interface Parser {
    (css: ParserInput, opts?: Pick<ProcessOptions, 'map' | 'from'>): Root;
  }
  interface Builder {
    (part: string, node?: Node, type?: 'start' | 'end'): void;
  }
  interface Stringifier {
    (node: Node, builder: Builder): void;
  }
  /**
   * Default function to convert a node tree into a CSS string.
   */
  const stringify: Stringifier;
  /**
   * Parses source CSS.
   * @param css The CSS to parse.
   * @param options
   * @returns {} A new Root node, which contains the source CSS nodes.
   */
  const parse: Parser;
  /**
   * Contains helpers for safely splitting lists of CSS values, preserving
   * parentheses and quotes.
   */
  export namespace list {
    /**
     * Safely splits space-separated values (such as those for background,
     * border-radius and other shorthand properties).
     */
    function space(str: string): string[];
    /**
     * Safely splits comma-separated values (such as those for transition-* and
     * background  properties).
     */
    function comma(str: string): string[];
  }
  /**
   * Creates a new Comment node.
   * @param defaults Properties for the new Comment node.
   * @returns The new node.
   */
  function comment(defaults?: CommentNewProps): Comment;
  /**
   * Creates a new AtRule node.
   * @param defaults Properties for the new AtRule node.
   * @returns The new node.
   */
  function atRule(defaults?: AtRuleNewProps): AtRule;
  /**
   * Creates a new Declaration node.
   * @param defaults Properties for the new Declaration node.
   * @returns The new node.
   */
  function decl(defaults?: DeclarationNewProps): Declaration;
  /**
   * Creates a new Rule node.
   * @param defaults Properties for the new Rule node.
   * @returns The new node.
   */
  function rule(defaults?: RuleNewProps): Rule;
  /**
   * Creates a new Root node.
   * @param defaults Properties for the new Root node.
   * @returns The new node.
   */
  function root(defaults?: object): Root;
  interface SourceMapOptions {
    /**
     * Indicates that the source map should be embedded in the output CSS as a
     * Base64-encoded comment. By default, it is true. But if all previous maps
     * are external, not inline, PostCSS will not embed the map even if you do
     * not set this option.
     *
     * If you have an inline source map, the result.map property will be empty,
     * as the source map will be contained within the text of result.css.
     */
    inline?: boolean;
    /**
     * Source map content from a previous processing step (e.g., Sass compilation).
     * PostCSS will try to read the previous source map automatically (based on comments
     * within the source CSS), but you can use this option to identify it manually.
     * If desired, you can omit the previous map with prev: false.
     */
    prev?: any;
    /**
     * Indicates that PostCSS should set the origin content (e.g., Sass source)
     * of the source map. By default, it is true. But if all previous maps do not
     * contain sources content, PostCSS will also leave it out even if you do not set
     * this option.
     */
    sourcesContent?: boolean;
    /**
     * Indicates that PostCSS should add annotation comments to the CSS. By default,
     * PostCSS will always add a comment with a path to the source map. PostCSS will
     * not add annotations to CSS files that do not contain any comments.
     *
     * By default, PostCSS presumes that you want to save the source map as
     * opts.to + '.map' and will use this path in the annotation comment. A different
     * path can be set by providing a string value for annotation.
     *
     * If you have set inline: true, annotation cannot be disabled.
     */
    annotation?: string | boolean;
    /**
     * Override "from" in map's sources.
     */
    from?: string;
  }
  /**
   * A Processor instance contains plugins to process CSS. Create one
   * Processor  instance, initialize its plugins, and then use that instance
   * on numerous CSS files.
   */
  interface Processor {
    /**
     * Adds a plugin to be used as a CSS processor. Plugins can also be
     * added by passing them as arguments when creating a postcss instance.
     */
    use(plugin: AcceptedPlugin): Processor;
    /**
     * Parses source CSS. Because some plugins can be asynchronous it doesn't
     * make any transformations. Transformations will be applied in LazyResult's
     * methods.
     * @param css Input CSS or any object with toString() method, like a file
     * stream. If a Result instance is passed the processor will take the
     * existing Root parser from it.
     */
    process(css: ParserInput | Result | LazyResult | Root, options?: ProcessOptions): LazyResult;
    /**
     * Contains plugins added to this processor.
     */
    plugins: Plugin<any>[];
    /**
     * Contains the current version of PostCSS (e.g., "4.0.5").
     */
    version: string;
  }
  interface ProcessOptions {
    /**
     * The path of the CSS source file. You should always set "from", because it is
     * used in source map generation and syntax error messages.
     */
    from?: string;
    /**
     * The path where you'll put the output CSS file. You should always set "to"
     * to generate correct source maps.
     */
    to?: string;
    /**
     * Function to generate AST by string.
     */
    parser?: Parser;
    /**
     * Class to generate string by AST.
     */
    stringifier?: Stringifier;
    /**
     * Object with parse and stringify.
     */
    syntax?: Syntax;
    /**
     * Source map options
     */
    map?: SourceMapOptions | boolean;
  }
  interface Syntax {
    /**
     * Function to generate AST by string.
     */
    parse?: Parser;
    /**
     * Class to generate string by AST.
     */
    stringify?: Stringifier;
  }
  /**
   * A promise proxy for the result of PostCSS transformations.
   */
  interface LazyResult {
    /**
     * Processes input CSS through synchronous and asynchronous plugins.
     * @param onRejected Called if any plugin throws an error.
     */
    then: Promise<Result>["then"];
    /**
     * Processes input CSS through synchronous and asynchronous plugins.
     * @param onRejected Called if any plugin throws an error.
     */
    catch: Promise<Result>["catch"];
    /**
     * Alias for css property.
     */
    toString(): string;
    /**
     * Processes input CSS through synchronous plugins and converts Root to
     * CSS string. This property will only work with synchronous plugins. If
     * the processor contains any asynchronous plugins it will throw an error.
     * In this case, you should use LazyResult#then() instead.
     * @returns Result#css.
     */
    css: string;
    /**
     * Alias for css property to use when syntaxes generate non-CSS output.
     */
    content: string;
    /**
     * Processes input CSS through synchronous plugins. This property will
     * work only with synchronous plugins. If processor contains any
     * asynchronous plugins it will throw an error. You should use
     * LazyResult#then() instead.
     */
    map: ResultMap;
    /**
     * Processes input CSS through synchronous plugins. This property will work
     * only with synchronous plugins. If processor contains any asynchronous
     * plugins it will throw an error. You should use LazyResult#then() instead.
     */
    root: Root;
    /**
     * Processes input CSS through synchronous plugins and calls Result#warnings().
     * This property will only work with synchronous plugins. If the processor
     * contains any asynchronous plugins it will throw an error. In this case,
     * you should use LazyResult#then() instead.
     */
    warnings(): Warning[];
    /**
     * Processes input CSS through synchronous plugins. This property will work
     * only with synchronous plugins. If processor contains any asynchronous
     * plugins it will throw an error. You should use LazyResult#then() instead.
     */
    messages: ResultMessage[];
    /**
     * @returns A processor used for CSS transformations.
     */
    processor: Processor;
    /**
     * @returns Options from the Processor#process(css, opts) call that produced
     * this Result instance.
     */
    opts: ResultOptions;
  }
  /**
   * Provides the result of the PostCSS transformations.
   */
  interface Result {
    /**
     * Alias for css property.
     */
    toString(): string;
    /**
     * Creates an instance of Warning and adds it to messages.
     * @param message Used in the text property of the message object.
     * @param options Properties for Message object.
     */
    warn(message: string, options?: WarningOptions): void;
    /**
     * @returns Warnings from plugins, filtered from messages.
     */
    warnings(): Warning[];
    /**
     * A CSS string representing this Result's Root instance.
     */
    css: string;
    /**
     * Alias for css property to use with syntaxes that generate non-CSS output.
     */
    content: string;
    /**
     * An instance of the SourceMapGenerator class from the source-map library,
     * representing changes to the Result's Root instance.
     * This property will have a value only if the user does not want an inline
     * source map. By default, PostCSS generates inline source maps, written
     * directly into the processed CSS. The map property will be empty by default.
     * An external source map will be generated — and assigned to map — only if
     * the user has set the map.inline option to false, or if PostCSS was passed
     * an external input source map.
     */
    map: ResultMap;
    /**
     * Contains the Root node after all transformations.
     */
    root?: Root;
    /**
     * Contains messages from plugins (e.g., warnings or custom messages).
     * Add a warning using Result#warn() and get all warnings
     * using the Result#warnings() method.
     */
    messages: ResultMessage[];
    /**
     * The Processor instance used for this transformation.
     */
    processor?: Processor;
    /**
     * Options from the Processor#process(css, opts) or Root#toResult(opts) call
     * that produced this Result instance.
     */
    opts?: ResultOptions;
  }
  interface ResultOptions extends ProcessOptions {
    /**
     * The CSS node that was the source of the warning.
     */
    node?: postcss.Node;
    /**
     * Name of plugin that created this warning. Result#warn() will fill it
     * automatically with plugin.postcssPlugin value.
     */
    plugin?: string;
  }
  interface ResultMap {
    /**
     * Add a single mapping from original source line and column to the generated
     * source's line and column for this source map being created. The mapping
     * object should have the following properties:
     * @param mapping
     * @returns {}
     */
    addMapping(mapping: mozilla.Mapping): void;
    /**
     * Set the source content for an original source file.
     * @param sourceFile The URL of the original source file.
     * @param sourceContent The content of the source file.
     */
    setSourceContent(sourceFile: string, sourceContent: string): void;
    /**
     * Applies a SourceMap for a source file to the SourceMap. Each mapping to
     * the supplied source file is rewritten using the supplied SourceMap.
     * Note: The resolution for the resulting mappings is the minimum of this
     * map and the supplied map.
     * @param sourceMapConsumer The SourceMap to be applied.
     * @param sourceFile The filename of the source file. If omitted, sourceMapConsumer
     * file will be used, if it exists. Otherwise an error will be thrown.
     * @param sourceMapPath The dirname of the path to the SourceMap to be applied.
     * If relative, it is relative to the SourceMap. This parameter is needed when
     * the two SourceMaps aren't in the same directory, and the SourceMap to be
     * applied contains relative source paths. If so, those relative source paths
     * need to be rewritten relative to the SourceMap.
     * If omitted, it is assumed that both SourceMaps are in the same directory;
     * thus, not needing any rewriting (Supplying '.' has the same effect).
     */
    applySourceMap(
        sourceMapConsumer: mozilla.SourceMapConsumer,
        sourceFile?: string,
        sourceMapPath?: string
    ): void;
    /**
     * Renders the source map being generated to JSON.
     */
    toJSON: () => mozilla.RawSourceMap;
    /**
     * Renders the source map being generated to a string.
     */
    toString: () => string;
  }
  interface ResultMessage {
    type: string;
    plugin: string;
    [others: string]: any;
  }
  /**
   * Represents a plugin warning. It can be created using Result#warn().
   */
  interface Warning {
    /**
     * @returns Error position, message.
     */
    toString(): string;
    /**
     * Contains the warning message.
     */
    text: string;
    /**
     * Contains the name of the plugin that created this warning. When you
     * call Result#warn(), it will fill this property automatically.
     */
    plugin: string;
    /**
     * The CSS node that caused the warning.
     */
    node: Node;
    /**
     * The line in the input file with this warning's source.
     */
    line: number;
    /**
     * Column in the input file with this warning's source.
     */
    column: number;
  }
  interface WarningOptions extends ResultOptions {
    /**
     * A word inside a node's string that should be highlighted as source
     * of warning.
     */
    word?: string;
    /**
     * The index inside a node's string that should be highlighted as
     * source of warning.
     */
    index?: number;
  }
  /**
   * The CSS parser throws this error for broken CSS.
   */
  interface CssSyntaxError extends InputOrigin {
    name: string;
    /**
     * @returns Error position, message and source code of broken part.
     */
    toString(): string;
    /**
     * @param color Whether arrow should be colored red by terminal color codes.
     * By default, PostCSS will use process.stdout.isTTY and
     * process.env.NODE_DISABLE_COLORS.
     * @returns A few lines of CSS source that caused the error. If CSS has
     * input source map without sourceContent this method will return an empty
     * string.
     */
    showSourceCode(color?: boolean): string;
    /**
     * Contains full error text in the GNU error format.
     */
    message: string;
    /**
     * Contains only the error description.
     */
    reason: string;
    /**
     * Contains the PostCSS plugin name if the error didn't come from the
     * CSS parser.
     */
    plugin?: string;
    input?: InputOrigin;
  }
  interface InputOrigin {
    /**
     * If parser's from option is set, contains the absolute path to the
     * broken file. PostCSS will use the input source map to detect the
     * original error location. If you wrote a Sass file, then 